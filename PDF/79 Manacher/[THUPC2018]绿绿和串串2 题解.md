# [[THUPC2018]绿绿和串串](https://www.fzoi.top/problem/6723)

> 本题较水，AK 的同学请不要大吼大叫……

## 题目描述

定义一个长度为 $n$ 的字符串的翻转操作为，将前 $n - 1$ 个字符复制一遍后倒序接在原串的末尾。如 `abcd` 进行翻转操作后，将得到 `abcdcba`。

给定长度为 $N$ 的字符串 $S$，求 $S$ 哪些前缀经过若干次翻转后得到的串可以覆盖 $S$，（即 $S$ 是最终串的前缀），输出每个符合条件的前缀长度。

多组数据，$|S|\leq 10^6,\sum |S| \leq 5\times 10^6$，$S$ 仅由小写字母组成。

## 样例数据

```
4
abcdcb
qwqwq
qaqaqqq
carnation
```

```
4 6
2 3 4 5
6 7
9
```

## 问题分析

直接从前缀开始翻转没有什么思路，我们倒着想。

### 怎样的串翻转后能覆盖 $S$？

**![](https://cdn.fzoi.top/upload/user/c20230135/22112108507089.png)**



如上图，**$T$ 在翻转后能覆盖 $S$，当且仅当 $T$ 的末尾（紫色）的最长回文半径的长度加上 $T$ 的长度等于 $N$。**

我们称这样的串 $T$ 为 "终止串"，或者称（黄色的）是后缀回文串。

知道了终止状态，我们继续观察翻转过程。

### 翻转后得到的串是怎样的？

根据翻转的定义，得到的串是一个奇回文串；同样地，有且仅有奇回文串可以由翻转得到。

那么能够由前缀翻转得到的就只有**前缀回文串**了。

### 怎么连续翻？

由上面的分析，我们大致可以得出思路了，**先选定一个初始串，然后一直翻，翻，翻……，中间状态都是由 $S$ 前缀回文串组成的**，最终变成一个终止串，由于一个长度为 $N$ 的串翻转后的长度**固定为 $2N-1$**，所以翻转次数在 $log\ N$ 级别。

> 我们还可以这样想，一个终止串经若干次划分，直到它不是奇回文串为止，中间的每一个前缀都是答案，但注意合法的终止串会有多个，所以不能只算一次。

### 算法流程

用 manacher 预处理终止串和前缀回文串，在末尾打上标记，对于每一个前缀，若通过固定的翻转，经过打上标记的前缀回文串后得到了终止串，那么输出，注意 $N$ 一定是答案，$1$（$N>2$ 时）一定不是答案。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 2e6 + 5;
int T;
int len[N], vis[N], tag[N];
char a[N];

int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%s", a + 1);
		int n = strlen(a + 1), mx = 1, mid = 1;
		a[0] = '$', a[n + 1] = '#';
		for (int i = 1; i <= n << 1; i++) vis[i] = tag[i] = len[i] = 0;
		for (int i = 2; i <= n; i++) {
			if (i <= mx) len[i] = min(len[mid * 2 - i], mx - i);
			while (a[i + len[i] + 1] == a[i - len[i] - 1]) len[i]++;
			if (i + len[i] > mx) mx = i + len[i], mid = i;
			vis[i + i - 1] = (i == len[i] + 1); // 前缀回文串
			tag[i] = (i + len[i] >= n); // 终止串
		}
		for (int i = 2; i < n; i++) {
			int j = i;
			while (vis[j + j - 1]) j = j + j - 1; // 通过前缀回文串一直翻
			if (tag[j]) printf("%d ", i); // 到了终止串
		}
		printf("%d\n", n);
	}
	return 0;
}
```

## 总结

这道题总的来说很简单，上面的步骤很容易理解，但至于思路的先后顺序，是直接想到还是不断碰壁因人而异，我因为没有罗盘所以挣扎了很久……

