T1
>有p^k个不同的棋子，将其分为若干组，每组恰好p个棋子，每对棋子至多在一个组中出现，问做多分多少组，且给出一个方案
每对棋子至多出现在一个组，也就是说任意两组的交集大小不能超过1。
没给大样例？很诡异，是不是怕我们大样例盯帧出答案？这个题应该不难，大概率是结论题
-----------------
我靠一小时要超了，刚想完第一遍，要快点
k=1的部分分肯定是直接输出全部
k=2？首先可以选出p组互不相同的，然后可以每个集合中任选一个，就是p^p个
于是我们得到了50分的高分。先写
p=2呢？只要任意两组之间不同即可，所以答案就是C(n,2a)
于是我们拿到了70分的高分
现在我们来思考一个问题：为什么p是质数？如果p是合数会有什么影响？
好像并不会有什么影响,但会影响合法的n的数量
通过打表，可以发现一个惊人的事实：合法的n中大多数k=1，只有极少数k>=3，且这些p都<=11，排除前面三个部分分，只剩下8个数了
于是我们可以打表！
写个爆搜就行了
但是代码长度会不会超啊……
肯定不会
不对啊，爆搜跑不动
想想怎么处理，突然感觉不是打表了
我们模仿k=2的思路，先搞出p^(k-1)个集合，然后任意选来组合。
这不就暴力嘛
答案是c(p,p^(k-1))*p^p+p^(k-1)
tm大概率会T，递归太慢了，不过如果出题者当当人还是有机会的
--------------------------------------------------------------------------
T2
一张n个点m条边的无向图，将其划分为k个集合，集合内的点之间的某条边通过的方案数为same[i]，不同集合间的边通过的方案数为diff[i]，问一共有多少种不同的方案数%=1000000007?两个方案不同当且仅当某个点所属集合不同或某条边的通过方式不同。
对于一个分配点的方案，在这个条件下的边的方案是很好求的，直接乘起来即可
没什么思路
-----------------
啊？
n怎么这么小
--------------------------------------------------------------------------

T3
有一种神秘的排序方法：
每次选择一下三种操作:
1.将a末尾的数压进栈b
2.将b顶的数压入栈c，b弹栈
3.c弹栈
c的弹栈序列倒过来即为目标序列（1~n）。
排序过程中，要求栈b从低到顶递减
问有多少长n的排列无法用这种方法排序，对输入的质数p取模
非常地怪异，但是我们又不需要把它排出来，还是减少了一点心里压力（上次海亮栈+队列的排序人都傻了）
b中的元素一定是a的一个上升子序列倒过来（废话），而每次加入b的一定是a中的一个最大值小于b顶的一个上升子段。c中的元素则是若干个b的子串，也就是a的若干个上升子序列。
这样好像看不出什么规律
能不能dp
我们设dp_i表示长度为i的排列有多少个不合法？打表找找规律
首先1~n递增和n~1递减都合法，不计入
要不写个爆搜来打表？等等吧，先手模
感觉好像和逆序对数量有关？
对于a的一段递增的子段，在b空的情况下，可以原样平移至c末尾或倒置；对于a的一段递减子段，在b空的情况下，可以倒置在c末尾
玛雅这个模着太难受了，先把T4看了然后打暴力
-----------------
突然想到暴力打出来没什么用的样子，我好像一个点都过不去
我还不如打表
--------------------------------------------------------------------------
T4
定义两个字符串模糊匹配为长度相等，且任意1<=i,j<=k，ai!=bi&&aj!=bj均有|i-j|<k
给定两个字符串s、p，求s的多少个连续子串是和p模糊匹配的
模糊匹配也就是任意两个不匹配的位置距离<k，也就是最靠前的不匹配位置与最靠后的不匹配位置距离<k
已知两个串，那么第一个不匹配的位置是可以哈希+二分求的。最后一个能不能？好像也可以
所以一个暴力想法诞生了：从1开始枚举，对于每个位置i，我们二分求出第一个和最后一个不匹配的位置然后判断。因为有n个询问，所以是O(|s|nlog|s|)的复杂度,获得了30分的高分（

