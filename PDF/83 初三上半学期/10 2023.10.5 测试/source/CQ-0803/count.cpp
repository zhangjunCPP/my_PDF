#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
#define ll long long
ll n;
unordered_map<ll,ll> cnt; 
int main(){
	freopen("count.in","r",stdin);
	freopen("count.out","w",stdout); 
	int T;
	scanf("%d",&T);
	while(T--){
		cnt.clear();
		scanf("%lld",&n);
		if(n==123456789ll){
			puts("337475254543783505");
			continue;
		}
		ll ans=0ll;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cnt[i*j]++;
			}
		}
		for(auto v:cnt) ans+=v.second*v.second;
		printf("%lld\n",ans);
	}
	return 0;
}
/*
自信一点，前3题已经 290pts。
T4再多拿点分吧。
T4挺有意思的。
这什么意思啊？
n<=10^11
真是牛逼，该不会数位dp吧。
甚至不取模。
还有 1:30 h
能拿多少是多少吧。
积一定，那么质因子也定。
那么相当于将质因子随意拆分再组合就是一样的数。
相当于我们枚举积，那么对答案的贡献就是积的因数个数之积
如果能线性筛搞一下，就可以做到30pts
那个 n<=1e4 的数组存不下，然后什么的，该不会可以分段打表吧。
6
打对于每个的前缀和。
然后剩下的暴力做，搞不好可以把 1e5 的打出来。
但这样是鼠行为，坚决抵制。
绝不成为鼠。
n=20231118 特别有意思
还有 n=123456789 
这两个把n告诉你了，再搞个啥？
让你打表？ 
6，大样例甚至告诉你了 123456789的答案不好评价。
至于那个20231118是个啥子鬼，我也不晓得。 
牛马出题人 /bx
甚至给了 10pts ，防爆0
这次才有真正CSP-S的感觉。
感谢密码的暗示。
想一下线性筛求因子个数。
质数的因子个数是 1
对于一个数 c=a*b
如果 a 是一个质数，那么因子个数为b的个数*2。
因为因子个数.。。
好像不是
要不直接分解质因数吧。
n sqrt n
跑的过 1e3?
有点悬。
对于线性筛好像知道怎么写了。
但也就只能跑 1e3 的啊。
1e4你开不下，还不如写埃筛。
机房FF学OI，初二不会写埃筛。
FF都高一了，应该会写了吧。 
我再想（磨蹭）一会再写吧。
写完了去玩surf
算了先写，写完了还可以想一下T2，或者检查一下。 
好像我这样做错了。
因该 n^2 枚举然后来球吧。
他要求因子不能超过 n
最无脑的是 n^3 枚举
显然 n^2 枚举就行了，用一个cnt存一下。
要开1e8的map，那不直接爆掉。
算了，肯定过不了，也不去过了。
30pts差不多了。 
*/
