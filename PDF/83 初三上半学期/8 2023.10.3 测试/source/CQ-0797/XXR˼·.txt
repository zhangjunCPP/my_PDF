T1

>给出一张无向简单图，有k个点是出口每个点。每个点有一个点权d，当位于的时会随机断开u的d条连边，离开u后又连上
暴搜30分
能否把魔法荆棘的设定转化为给边定向？
-----------------------------------------
由于我们知道边权都为正，所以每个点最多经过一次，所以我们对于每个点的荆棘怎么用只需要考虑一遍就行了，也就是说我们可以在跑之前就给它们定向。
或者说不叫定向，我们直接把无向图转为有向图，每个点可以删掉d个出边，求到任意一个出口的最短路最长是多少
任意一个出口这个很烦，要不我们直接把出口合并为一个点？好像没有什么影响。
所以就有了一个暴力的想法：跑最短路，如果一条边在最短路图上就尝试删掉它。如果发现最短路图起点终点不连通了，就再跑一次。一直循环直到再怎么合法删边都不影响最短路
怎么给我一种像网络流一样的感觉
时间复杂度O(nlogn\sum{d})，最坏是O(n logn m^2)级别的，这**和鲍丽芬有什么区别？哦有两组性质点，30分，加起来就60了，也不差。
考虑优化？但是这里d的和就已经炸了。哦不对！！！最多删2m次边，所以是O(nmlogn)级别的！获得了80分的高分！！！！！！！！
跑不满，大概是会比80高一点……吧
非常地快乐啊，今天必须把这题切了
写一下优化方向
1. 最短路图是张DAG，能不能搞？
2. 优化跑最短路的过程？
3. 一次多删些边？
4. 快速删边、验证答案
第三种思路感觉没什么前途，不好
第四种也没有卵用，复杂度瓶颈在dij
现在我们只能允许一个log的复杂度了，除非小常数
等会，先把T2想想
-----------------------------------------
我靠问题好像没有这么简单
能确保每次删掉最短路图上可删的点是最优的吗
好像并不是哦
好吧可以保证
问题确实就这么简单
-----------------------------------------
出现问题了，如果删边删不完也是有可能割完的
割？最小割？（什么东西
那现在又要解决一个价值80分的问题：一张dag上删掉一些边，每个点删掉的出边数量有限，能否使1~n不连通？要求O(n)
建个反图，跑拓扑。在反图上：如果某个点的入度大于d，且有一个入边的起点是可达的，那么这个点也是可达的。
但是我们还需要方案。
方案乱搞即可。
----------------------------------------
啊？
大样例怎么过了没T
99633个出口，这是天安门广场是吧
----------------------------------------
又来了奥
删完一次边之后最短路图一定是被割成两半
这两半之间其实是有些边的，但不在最短路图内。能否每删掉一些边就用这些原本没选上的边来更新？
对啊好有道理
不对，完全错误，T
能不能自欺欺人把这个复杂度分析降下去？
好像也不行的样子，就算能降也是O(n\sqrt{n}\log n)的复杂度，根本过不去
二分答案是否可行？（我怎么现在才想到这个
G好像真的可以！验一下单调性？
如果x这个路可以通过删掉一些边使其不合法，那么更大的呢？
不对我怎么写check，写锤锤
---------------------------------------------------------------------------
T2
把序列划分为若干段长度为1或2，最小化所有区间权值和的极差
dp
设dp[i]表示从1~i中最小的极差。
好像不对，dpi中应该存一个最大最小值什么的
mn_i表示1~i最小值最大是多少？
也不对……
反悔贪心？先全部单独一个，找到最小的和左/右合并，再整个ctrl+z操作？
待会想，先把T34看了
-----------------------------------------
反悔贪心好像很有前途
每次找到最小的位置，把它和两边某一个合并
如果两边某一个已经被合并了，递归尝试将这一个换人。这样复杂度有点高，但是O(n^2logn)还行
等等，这个递归的过程我怎么想到了二分图匹配？？？先把这个想法放一放
现在遇到一个问题：合并可能改变最大值
如果合并后改变最大值会使答案更优还好说，肯定要合并，但如果不会呢？总不能搜吧，又回到搜索了
-----------------------------------------
受不了了，直接搜
---------------------------------------------------------------------------
T3
对于S的每个后缀，把它分为4段，第1、2、4相同，求方案数
万恶的字符串
因为问的是后缀，所以一定有性质
判断1、2、4相同一定是哈希嘛
对于i这个后缀，我们要找到一个长度j，使得[i,i+j-1]=[i+j,i+2j-1]=[n-j+1,n]，且n-j+1>i+2j（3j<n-i）
初步想法只有暴力枚举+哈希判断，不过鲍丽芬好像挺高的
保险起见我们整个双哈希
-----------------------------------------
我们来愉快地找性质
能否使用妙妙道具，比如kmp、exkmp之类的算法
不对啊这些东西我又不会……没事，万能哈希，最多就多个log的事嘛
这个东西有个鬼的性质啊喂
现在大概的思路两个：（废话
1.找两个相邻后缀间的关系
2.加速查找
由于它问的是后缀，所以大概率是第一个思路
哎先不看这个了，价值30分的正解性价比还不如20分的搜索
-----------------------------------------
我又天姥回来了嘿！
完全不会
我又走了
---------------------------------------------------------------------------
T4
给出b数组的二进制表示，对于a数组要满足ai>bi，任意两个ai、aj（i!=j）与起来是0，求a数组的最小或，输出二进制
分位考虑。
对于第i位，只能有一个1。
大概是从低往高的推？
没有思路啊
待会想
-----------------------------------------
puts("-1")（喜