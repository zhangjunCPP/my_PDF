mmd，要建子文件

## T1

> n个点m边的简单无向联通图，给出操作顺序，如果某个人删边之后不连通，则输

感觉很水的样子，如果不是一棵树那肯定乱删

所以答案是S[(m-n+1)%k+1]^1

记得把边也输入进来

## T2

首先一个很显然的想法，直接模拟，60分

判断是否存在开set会少25分，用标记数组。找最早的用堆会少25，用队列

能不能转图论问题？每个事件向下一个访问数字相同的位置连边？好像没什么用

其实总的插入次数就是总的删除次数+k

没什么思路

---

这个队列带删啊

没事，再开一个标记数组表示删除了几次

---

哎等等等等，ai小于等于n是什么东西

---

首先k=n的情况肯定答案为m，答案肯定是递减的嘛

现在少了一个会怎么样？不知道

换个思路，能不能算出一个数被删除的时间？先考虑当前这个数在被删除之前都不会被访问。

 二分？假设我们现在拿到一个时间，怎么验证在此之前这个数是否被删掉？

假设当前我们的位置为i，二分到mid，设cnt[i,j]表示区间[i,j]内出现了多少个不同的数字，x为最后一个cnt[1,x]==k的位置

当i<=x如果cnt[1,x]-cnt[i,x]<=cnt[i,mid]-cnt[i,x]，趋势

否则如果cnt[1,i]<=cnt[i+1,]

md柿子错了，懒得推了，这个东西推出来也没什么帮助，不可能整体二分吧，状态数都超了

整理一下思路

1. 加速solve过程
2. 从每个数算对每个k的贡献

观察一下样例，一个数会让答案+1，当且仅当这个数还有下一次出现且这个位置j和当前位置i满足j-i-1>=k……吗？

不对，j-i-1算的是中间数字的个数，我们要的应该是不同的数字的个数，这里能用主席树。

于是对每个位置i找到下一次ai出现的位置j（不存在或j=i+1则跳过），把ans[cnt[i+1,j-1]]++，最后给ans数组作后缀和

好像就做完了

JO！写个暴力求cnt的版本

我靠完全正确！！！！

唉主席树怎么搞

不管了，线段树套set

哎也不对啊

哦，我应该用莫队

会不会被卡啊

我靠跑起来飞快

## T3

一条直线上有若干个棋子，每次可以把一颗棋子跳到相邻棋子的另一侧，有的位置初始有无棋子未知，问总共可能会有多少种跳的方案

初始局面不同，就视为最终局面不同。

其实这个操作方式可以视为把两颗相邻的棋子一起平移一个单位距离

问号™难受死了，没有问号都没搞出来。先想没有问号的情况

完全不会

## T4

虚树是tm个什么玩意

这个数据范围当然能用莫队

但是我tm连虚树是个啥都不知道，紫砂