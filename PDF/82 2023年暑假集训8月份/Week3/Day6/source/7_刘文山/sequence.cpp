#include<bits/stdc++.h>
using namespace std;
int n,k;
const int maxn=45,maxk=255; 
int main(){
	freopen("sequence.in","r",stdin);
	freopen("sequence.out","w",stdout);
	cin>>n>>k;
	while(1){
		cout<<"肘鸡\n";
	} 
	return 0;
}
/*
T2 是 T1 的逆向题目？ 出题人真会玩。
输出的挺多的那就只好dp。
dp i j 表示前 i 个数出现了 j 个的方案数。
不太好考虑哈。
如果在一个串的后面添入一个 0 或 1 会发生什么。
会有重复，不好做。
n<=40 就让人很无语。
刚好不大不小的。
对 998244353 取模有可能是诈骗。
因为当 n 很大时，感性理解随随便便他的非空本质不同子序列的个数就超过了 k。
方案数并不大。
怎么求本质不同子序列的个数？
暴力第一档都过不了。
考虑一下性质吧。
肯定我先找到第一个 0 和 1。
那么后面能组成序列前面一定能组成。
就是重复了。
这样也会算重复，烦。
考虑把 0/1 看成 2 进制数。
那么一个序列和另一个序列重复，只有。。。
好像有点 sber。
序列很烦耶，但凡是个串都还好。
没法用串代替序列。。。。
 n 都到 40 了，不能和枚举扯上关系。
总不可能给我说这个是网络流吧。。。。
网络流跑方案那不是傻逼行为吗？
md 老子但凡能打个表也就过了。
打了 1~12 的表，不是很好搞。
最后想到个 30 pts 的做法：
枚举每个子序列看他出现在哪些串中。
sber 了，好像不是 30 pts 的做法。
看时间吧，只能是一个多项式复杂度的算法。
。。。。。。
。。。。。。
。。。。。。
。。。。。。
。。。。。。
。。。。。。
想了半天，暴力都打不出来。
真的成 FF 了。
原地摆烂，还有 20 min。 
*/

