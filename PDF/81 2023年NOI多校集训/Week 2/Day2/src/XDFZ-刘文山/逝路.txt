T1
n<=1e7，真是牛逼。
正解应该是直接递推或者矩阵乘法或者找规律吧。
这个东西虽然有点怪糟糟的，还是有点像括号序列？
考虑前面一坨不变，后面的就是之前的答案，加个前缀和什么的搞一下。
大悲，似乎没搞出来，基于这个做法，好像要先求一下 P==Q 的方案数。
考虑求这个方案数，不对，我求出了方案数，我可以直接（总方案-相同的方案）/2就行了。
似乎没有这么麻烦，反正两种方法都要求相同的方案数，那还不如先求了再说。
不难发现，P==Q 时，一定要满足 i==PPi 所以他们要么是两两组队，要么就是独立为一对。
那么就应该有一个递推式：
设 g n 表示长度为n的序列的方案数
g n=g n-1 +  g n-2 * （n-1）
表示要么自己和自己组队，要么选一个之前的和自己组队。
然后这题就可以直接递推做了。
T2
先考虑是一条链的情况。
似乎考虑错了，但是无伤大雅，直接对树的情况做，学习FF，自信一些。
如果直径同色，那么他的贡献为 2^(n-1) * len 。
是的，剩下的情况就是直径异色。
如果直径异色的话，那么最长的路径一定和直径有关。
所以可以枚举最长的路径，从大到小。
如果那个节点之前未出现过，就说明他的颜色没有定过，就可以直接用未定过的颜色直接计算贡献。
如果出现过一次，就说明他的颜色定过，并且这个颜色是反色，后面的颜色无论怎么选都不会成为最长的了，所以计算完贡献就可以Say goodbye 了。
时间复杂度 : n log n
T3
超集是什么鬼，跳过。
好像可以用枚举子集得15pts，但是不想去打，没什么意义。
T4
只有一个点，那么可以先枚举一下这个点，强行断开后再来求答案，好像时间复杂度 sub 1都过不了。
C
我觉得时间就像海绵里的水，万一卡一卡就有了呢？
好像对于一整颗子树求一次最长序列只需要对于每个叶子节点从下往上求一次最长不下降子序列和最长不上升子序列合并一下就行了。
大雾，时间复杂度和边数有关，感性理解是 n^2 再加上枚举 n^3 过一下 sub1 差不多了。
是的，如果是一个菊花图，我搞不好还能卡过 sub2 真是牛逼。
我突然想到了，能不能使用点分治！。
搞出一个beutiful的东西，就可以乱搞了。
时间还有40min了，似乎打不完点分治，大悲。
能不能选择不打了呀。
悲伤。
我就打个正常的吧，万一数据给的好就有了呢？

